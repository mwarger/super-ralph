{{!-- Decompose Phase: spec -> beads --}}
{{!-- The agent autonomously discovers and creates beads from the spec. --}}

## Your Mission

You are one iteration of a decompose loop. You have a fresh context — no memory of previous iterations. Read the spec, assess what work remains to be covered, and create the next bead.

## The Spec

{{{specContent}}}

## Epic: {{epicId}}

{{#if existingBeads.length}}
## Beads Created So Far

{{#each existingBeads}}
- {{this.id}}: {{this.title}} ({{this.status}})
{{/each}}

Review what exists. Identify gaps — what part of the spec isn't yet covered by a bead?
{{else}}
No beads created yet. Start with the foundational work — what needs to be built first?
{{/if}}

## Task Sizing

Each bead should be:
- **Small enough** to implement, test, and commit in a single forward iteration (5-15 minutes of agent work)
- **Self-contained** — a fresh agent with no memory can pick it up and complete it
- **Verifiable** — has clear acceptance criteria that can be mechanically checked
- **Self-documenting** — description includes background, reasoning, and context so a fresh agent understands what to do and why

If a task feels too large to describe in 2-3 sentences, split it into smaller beads.

## Planning Guidance

### Ordering and Dependencies
- Create foundational beads first (schema, data models, core types)
- Group related work into natural phases (core -> edge cases -> polish)
- Wire `--depends-on` so beads unblock in a sensible order
- Later beads should depend on the beads they need completed first

### Review and Quality Checkpoints
{{#if includeReview}}
- Add **review beads** at natural phase boundaries (e.g., after core implementation, before moving to edge cases)
- Review beads should diff all changes from their phase against the spec and check for drift
{{/if}}
{{#if includeBugscan}}
- Add **bugscan beads** after review beads — a fresh-eyes pass looking for bugs, errors, silly mistakes
{{/if}}
{{#if includeAudit}}
- Add an **audit bead** as one of the final beads — a comprehensive review of the entire implementation
{{/if}}
- Add a **learning extraction bead** as the very last bead — extract lessons, update intake checklist
- Scale the number of checkpoints to complexity: a 3-bead hotfix needs no review beads, a 20-bead feature needs several

### Area Labels for Model Routing
Use `--label "area:<type>"` to enable model routing. Common areas:
- `area:frontend-design` — UI components, pages, styling
- `area:backend` — server logic, APIs, data processing
- `area:schema` — database migrations, data model changes
- `area:test` — test infrastructure, test utilities
- `area:review` — review, bugscan, and audit beads
- `area:docs` — documentation updates

## Creating a Bead

Use `br` CLI to create each bead:

```bash
br create --parent {{epicId}} \
  --title "US-NNN: <Title>" \
  --description "$(cat <<'EOF'
<Self-contained description with context, reasoning, and acceptance criteria>

## Acceptance Criteria
- [ ] <specific, verifiable criterion>
- [ ] <specific, verifiable criterion>
- [ ] Quality gates pass
EOF
)" \
  --label "area:<type>" \
  --depends-on "<dependency-id>" \
  --priority <1-4>
```

> **CRITICAL:** Always use `<<'EOF'` (single-quoted) for HEREDOC delimiters to prevent shell interpretation.

## When to Stop

- Signal `task_complete` with `status: "complete"` after creating a bead — the loop continues
- Signal `task_complete` with `status: "phase_done"` when the spec is fully covered — every requirement has at least one bead
- Don't over-decompose — if the spec is simple, 3-5 beads may be enough
- Don't under-decompose — every requirement in the spec should be traceable to a bead
